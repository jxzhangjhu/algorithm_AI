
## Double pointer 双指针
### 使用条件
1. 滑动窗口 - 90% 的概率
2. 时间复杂度要求 O(n) - 80%的概率
3. 要求原地操作，只可以交换使用，不能使用额外空间，所以空间复杂度O(1) - 80% 
4. 有子数组subarray， 子字符串substring的关键词 - 50%
5. 有回文问题 palindrome 关键词 - 50% 

### time complexity
>> 时间复杂度与最内层循环主体的loop执行次数有关， 与有多少重循环无关，O(n) 
### space complexity
>> 只需要分配2个指针的额外内存，所以space 是O(1)

### 几种类型的双指针及相关题目
1. 同向：特点是指针不回头，全0 子串数量 - slow，fast， 基本等价于sliding window 
2. 相向：two sum， three sum， left， right
3. 背向：最长回文子串

### 相向双指针 - two sum 为主 start and end； 还有partition类型
Template
```python
class Solution:
    def patition(self, A, start, end):
        if start >= end:
            return 

        left, right = start, end
        # key point 1: pivot is the value, not the index 
        pivot = A[(start + end) // 2]
        # key point 2: every time you compare left & right, it should be left <= right not left < right 
        while left <= right:
            while left <= right and A[left] < pivot:
                left += 1
            while left <= right and A[right] > pivot: 
                right -= 1
            if left <= right:
                A[left], A[right] = A[right], A[left]
                left += 1
                right -= 1
```
### Problems
- #1. Two Sum 
    > 暴力double for loop -> hashtable -> 排序双指针(如何排序 + index操作需要注意); 这里要求返回下面，如果返回值比较容易
 





### 同向双指针 - 快慢指针 slow，fast； slideing window - 区间题
Template  - 九章，这个不太通用，很多用不了！
```python
class Solution:
    def patition(self, A, start, end):
        j = 0
        for i in range(n):
            # 不满足则循环到满足搭配为止

            while j < n and i and j 之间不满足条件:
                j += 1

            if i到j之间满足条件:
                处理i到j这段区间 

```






### 背向双指针 - 回文子串题
Template 
```python
class Solution:
    def patition(self, A, start, end):

        left = position 
        right = position + 1
        while left >=0 and right < len(s):
            if left and right 可以停下来了：
                break

            left -= 1
            right += 1 


```



















---
## Binary search 二分法

### 使用条件
1. 排序数组（30%-40% 是二分法）
2. 当面试官要求找一个比o(n)更小的时间复杂度算法的时候，99% 就是二分logn
3. 找到数组中的一个分割位置，使得左半部分满足某个条件，右半部分不满足 100% 就是二分
4. 找到一个最大、最小的值使得某个条件被满足 90% 
> time complexity - o(logn)； space complexity o(1)

### template 
```python
class Solution:
    def binary_search(self, nums, target):
        # corner case 处理 - 这里等价于num is None or len(num) == 0
        if not nums: return -1 
        # 初始化
        start, end = 0, len(nums) - 1
        # 用start + 1 < end 而不是 start < end 的目的是为了避免死循环
        # the first position of target 的情况下不会出现死循环，但是在last position of target 的情况下会出现死循环
        # example, nums = [1, 1]， target = 1 
        while start + 1 < end:
            mid = start + (end - start) // 2 
            # or mid = (start + end) // 2
            # > = < 的逻辑先分开写，然后在看看 = 的情况是否能合并到其他分支里
            if nums[mid] < target: 
                start = mid 
            elif nums[mid] == target:
                end = mid 
            else: 
                end = mid 
            # 因为上面的循环退出条件是 start + 1 < end 
            # 因此这里循环结束的时候， start 和 end 的关系是相邻关系 (1和2，3和4 这种)
            # 因此需要再单独判断 start 和 end 这两个数谁是我们想要的答案
            # 如果是找 first position of target 就先看start， 否则就先看end 
            if nums[start] == target:
                return start 
            if nums[end] == target: 
                return end 
        return -1 

```
### 1891 cut 木头的题，需要判定函数
```python
class Solution:
    def maxLength(self, ribbons: List[int], k: int) -> int:
        
        # 核心的难点是，能不能cut，我能想到左右边界1， max，但要定义一个cut函数
        # 这个函数就是说给定一个target，能不能cut用现在的ribbons
        
        def can_cut(target):
            count = 0 
            for num in ribbons:
                count += num // target    
            return count >= k 
        
        start, end = 1, max(ribbons)
        while start + 1 < end:
            mid = (start + end) // 2
            if can_cut(mid):
                start = mid 
            else:
                end = mid 
        
        if can_cut(end): return end
        if can_cut(start): return start
        
        return 0
```

### Problems
#### 显式二分
- #35. Search Insert Position https://leetcode.com/problems/search-insert-position/
    > 模板题

**多次二分** 
- #34. Find First and Last Position of Element in Sorted Array https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ 
    > 找排序数组的左右边界, 直接用模板，二次二分法
- #33. Search in Rotated Sorted Array https://leetcode.com/problems/search-in-rotated-sorted-array/
    > 也是从分割点，应用二次二分法

**山峰+多次二分** 
- #852. Peak Index in a Mountain Arrayhttps://leetcode.com/problems/peak-index-in-a-mountain-array/
    > 山峰最easy题
- #1095. Find in Mountain Array https://leetcode.com/problems/find-in-mountain-array/ 
    > 是一个hard， 首先二分要在sorted 上做，否则不work，上来先排序，然后找到peak value 用一次二分，然后分别堆两部分做2次二分
- #162. Find Peak Element https://leetcode.com/problems/find-peak-element/
    > 山峰类型题，根据要求，判断相邻大小然后对start 和 end check
- #1901. Find a Peak Element II https://leetcode.com/problems/find-a-peak-element-ii/ 
    > 山峰改为2D矩阵，比较难相比之前

**math + API 熟悉二分思想**
- #367. Valid Perfect Square https://leetcode.com/problems/valid-perfect-square/
    > math 题，练习二分思想
- #278. First Bad Version https://leetcode.com/problems/first-bad-version/ 
    > call API 的题，这里面target不是number，而是true or false
- #374. Guess Number Higher or Lower https://leetcode.com/problems/guess-number-higher-or-lower/
    > API 题，类似278，经典二分思想 
- #633. Sum of Square Numbers https://leetcode.com/problems/sum-of-square-numbers/
    > math 题，开始以为二分，但其实双指针更容易

**矩阵+二分**
- #74. Search a 2D Matrix https://leetcode.com/problems/search-a-2d-matrix/ 
    > 矩阵题，类似graph，一直处理的不好，这个题要重新做， 用模板 0307 update
- #240. Search a 2D Matrix II  https://leetcode.com/problems/search-a-2d-matrix-ii/
    > 矩阵题，可以暴力干，不是特别典型的二分，需要重新做，用模板，0307 update


#### 隐式二分
**不太理解的几个二分**
- #540. Single Element in a Sorted Array https://leetcode.com/problems/single-element-in-a-sorted-array/ 
    > 仍然不是很清楚，如何确定二分的条件，这个题需要理解成，奇偶数判断，然后移动mid， 需要再做
- #644. Maximum Average Subarray II https://leetcode.com/problems/maximum-average-subarray-ii/ 
    > 是一个hard，用到了前缀和，没做出来，需要再做
- #528. Random Pick with Weight https://leetcode.com/problems/random-pick-with-weight/
    > 不理解题含义

**写判定函数，注意边界**
- #1300. Sum of Mutated Array Closest to Target https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/ 
    > 一类题，需要写一个判定函数，然后注意边界，start, end = 0, max(arr) 否则出错
- #1060. Missing Element in Sorted Array https://leetcode.com/problems/missing-element-in-sorted-array/
    > 比1300 复杂，需要写missing function，不在边界内，如何选，处理边界问题， good题
- #1891. Cutting Ribbons https://leetcode.com/problems/cutting-ribbons/ 
    > 核心的难点是，能不能cut，我能想到左右边界1， max，但要定义一个cut函数:给定一个target，能不能cut用现在的ribbons
- #1011. Capacity To Ship Packages Within D Days https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/ 
    > 考判定函数的题，非常经典， 很多类似的题
- #875 Koko Eating Bananas  https://leetcode.com/problems/koko-eating-bananas/
    > 判定函数，和1011类似，一个模板可解决，注意边界是start, end = 1, max(piles)
- #1231. Divide Chocolate https://leetcode.com/problems/divide-chocolate/
    > 1011，875 同类型题，注意有一个边界case，需要单独处理
- #410. Split Array Largest Sum https://leetcode.com/problems/split-array-largest-sum/
    > 判定函数，start, end = max(nums), sum(nums) 注意细节，是个hard但不难

**二分混合其他**
- #2089. Find Target Indices After Sorting Array https://leetcode.com/problems/find-target-indices-after-sorting-array/
    > 多种解法，有一个统计解法，二分其实不是最优的
- #1062. Longest Repeating Substring https://leetcode.com/problems/longest-repeating-substring/
    > 哈希表+判断函数，这个是string，注意边界，start, end = 0, n

---
&emsp;
&emsp;
&emsp;

## Sorting 排序
python自带的sorted 排序算法是timsort
> best time - o(n), average and worst case is o(nlogn);  space o(n)

```python 
s = [1,5,3,6,2]
sorted(s) # [1, 2, 3, 5, 6]
sorted(s,reverse=True) #[6, 5, 3, 2, 1]
boxTypes = [[5,10],[2,5],[4,7],[3,9]]
sorted(boxTypes, key=lambda x:x[0]) # [[2, 5], [3, 9], [4, 7], [5, 10]]
sorted(boxTypes, key=lambda x:x[1]) # [[2, 5], [4, 7], [3, 9], [5, 10]]
sorted(boxTypes, key=lambda x:x[0], reverse=True) # [[5, 10], [4, 7], [3, 9], [2, 5]]
```

### Quick sort - time o(nlogn), space o(1)
> 先整体有序，再局部有序，利用分治的思想，递归的程序设计方式

```python
def sortIntegers(self, A):
    if A is None or len(A) == 0:
        return 
    self.quick_sort_helper(A, 0, len(A), 1)

def quick_sort_helper(self, A, start, end):
    # 递归的出口
    if start == end:
        return

    # 递归的拆解
    left, right = start, end 
    mid = A[start + (end - start) // 2]

    while left <= right:
        while left <= right and A[left] < mid:
            left += 1
        while left <= right and A[right] > mid:
            right -= 1
        if left == right:
            # 左右交换
            A[left], A[right] = A[right], A[left]
            left += 1
            right -= 1
    #递归
    self.quick_sort_helper(A, start, right)
    self.quick_sort_helper(A, left, end)
```

### Merge sort - time o(nlogn), space o(n)
> 先局部有序，再整体有序

```python
class Solution:
    def sorintegers(self, A):
        if not A:
            return A 

        temp = [0] * len(A) # 新开的space 所以o(n)
        self.merge_sort(A, 0, len(A) - 1, temp)

    def merge_sort(self, A, start, end, temp):
        if start >= end:
            return 

            # 处理左半区间
            self.merge_sort(A, start, (start + end) // 2, temp)
            # 处理右半区间
            self.merge_sort(A, (start + end) // 2 + 1, end, temp)
            # 合并排序数组
            self.merge(A, start, end, temp)

    def merge(self, A, start, end, temp):
        middle = (start + end) // 2
        left_index = start
        right_index = middle + 1
        index = start 

        while left_index <= middle and right_index <= end:
            if A[left_index] < A[right_index]:
                temp[index] = A[left_index]
                index += 1
                left_index += 1
            else:
                temp[index] = A[right_index]
                index += 1
                right_index += 1

        while left_index <= middle:
            temp[index] = A[left_index]
            index += 1
            left_index += 1

        while right_index <= end:
            temp[index] = A[right_index]
            index += 1
            right_index += 1

        for i in range(start, end + 1):
            A[i] = temp[i]

```


### Problems
- #148. Sort List https://leetcode.com/problems/sort-list/ 
    > 超级麻烦，要有merge sort，感觉这种排序题在linked list 难度很大，而且容易出
- #179. Largest Number https://leetcode.com/problems/largest-number/
    > 不理解，官方答案超玄乎，但还是高频很多地方考过！
- #75. Sort Colors https://leetcode.com/problems/sort-colors/ 
- #493. Reverse Pairs https://leetcode.com/problems/reverse-pairs/ 
- #23. Merge k Sorted Lists  https://leetcode.com/problems/merge-k-sorted-lists/ 




