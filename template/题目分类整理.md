## python 基础和常用技巧

- log.split(' ', 1) # 分割字符串
- log.isdight() 判断是否为数字
- alpha.sort(key = lambda x: (x[1],x[0])) # 则会根据参数的第一个字段，第二个字段按照正序排列
- alpha.append((s[0],' '.join(j for j in s[1:]))) # join 就是加上
- join 用法和定义 Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。 
    > The join() method takes all items in an iterable and joins them into one string. A string must be specified as the separator.

---
## Array and string 







---
## Double pointer 双指针
### 使用条件
1. 滑动窗口 - 90% 的概率
2. 时间复杂度要求 O(n) - 80%的概率
3. 要求原地操作，只可以交换使用，不能使用额外空间，所以空间复杂度O(1) - 80% 
4. 有子数组subarray， 子字符串substring的关键词 - 50%
5. 有回文问题 palindrome 关键词 - 50% 

### time complexity
>> 时间复杂度与最内层循环主体的loop执行次数有关， 与有多少重循环无关，O(n) 
### space complexity
>> 只需要分配2个指针的额外内存，所以space 是O(1)

### 几种类型的双指针及相关题目
1. 同向：特点是指针不回头，全0 子串数量 - slow，fast， 基本等价于sliding window 
2. 相向：two sum， three sum， left， right
3. 背向：最长回文子串

### 相向双指针 - two sum 为主 start and end； 还有partition类型
Template
```python
class Solution:
    def patition(self, A, start, end):
        if start >= end:
            return 

        left, right = start, end
        # key point 1: pivot is the value, not the index 
        pivot = A[(start + end) // 2]
        # key point 2: every time you compare left & right, it should be left <= right not left < right 
        while left <= right:
            while left <= right and A[left] < pivot:
                left += 1
            while left <= right and A[right] > pivot: 
                right -= 1
            if left <= right:
                A[left], A[right] = A[right], A[left]
                left += 1
                right -= 1

# two sum 先排序，才能用相向双指针 
            nums = [(number, index) for index, number in enumerate(nums)]
            nums.sort()
            
            left, right = 0, len(nums) - 1
            while left < right:
                if nums[left][0] + nums[right][0] < target: # 小于target，left 右移
                    left += 1
                elif nums[left][0] + nums[right][0] > target: # 大于target，right 左移
                    right -= 1
                else: # 这个必须要有，就是说 == target，直接返回
                    return sorted([nums[left][1], nums[right][1]]) # 是否拍需要看要求，这个需要从小到大，就排一下
            return 
# three sum
        if len(nums) < 3:
            return 
        
        n = len(nums)
        nums.sort()
        ans = []
        for i in range(n):
            left = i + 1
            right = n - 1
            if nums[i] > 0: #最小值大于0
                break
            if i >= 1 and nums[i] == nums[i-1]: # 差一点，i >=1 才行，这种去重的题还是挺不好弄的！
                continue # 如果相邻的重复，那么就move一下，去掉重复的，直接跳过这个loop
            # left, right = 0, n - 1 # 不是这样的，要和i相关
            while left < right:
                target = nums[i] + nums[left] + nums[right]
                if target < 0:
                    left += 1
                elif target > 0:
                    right -= 1
                else:
                    ans.append([nums[i], nums[left], nums[right]])
                    while left != right and nums[left] == nums[left + 1]: # 去重 left
                        left += 1
                    while left != right and nums[right] == nums[right - 1]: # 去重 right
                        right -= 1
                    left += 1
                    right -= 1
        return ans
# 4sum hashmap, time o(n^2), space o(n^2)
        hashmap = {}
        for i in nums1:
            for j in nums2:
                if i + j in hashmap:
                    hashmap[i + j] += 1
                else:
                    hashmap[i + j] = 1
            
        res = 0
        for m in nums3:
            for n in nums4:
                if 0 - m - n in hashmap:
                    res += hashmap[0 - m - n]
                    
        return res
```

### Problems
- #1. Two Sum 
    > 暴力double for loop -> hashtable -> 排序双指针(如何排序 + index操作需要注意); 这里要求返回下面，如果返回值比较容易
- #167. Two Sum II - Input Array Is Sorted https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ 
    > 排序之后返回index，比two sum 简单， 我觉得只有排序之后，才能相向双指针，否则没有意义
- #15. 3Sum https://leetcode.com/problems/3sum/
    > 最外层for loop 作为一个指针，内嵌while loop，考虑left，right指针, 这个难点在于去重，去重很多种办法， 包括set，还有左右移动，因为已经排序，所以用相邻位置的比较来去重
- #16. 3Sum Closest https://leetcode.com/problems/3sum-closest/ 
    > 比15简单，几个edge cases都考虑到了
- #259. 3Sum Smaller https://leetcode.com/problems/3sum-smaller/ 
    > res += right - left # 这步是关键，之前没有想清楚， 为什么是right-left，其实就是中间的都可以
- #18. 4Sum https://leetcode.com/problems/4sum/ 
    > 完全和3sum一样！ 就是复杂的一点, time o(n^3), space o(n) 
- #454. 4Sum II https://leetcode.com/problems/4sum-ii/ 
    > # hashmap, time o(n^2), space o(n^2) 



### 同向双指针 - 快慢指针 slow，fast； slideing window - 区间题
Template  - 九章，这个不太通用，很多用不了！
```python
class Solution:
    def patition(self, A, start, end):
        j = 0
        for i in range(n):
            # 不满足则循环到满足搭配为止

            while j < n and i and j 之间不满足条件:
                j += 1

            if i到j之间满足条件:
                处理i到j这段区间 

```











### 背向双指针 - 回文子串题
Template 
```python
class Solution:
    def patition(self, A, start, end):

        left = position 
        right = position + 1
        while left >=0 and right < len(s):
            if left and right 可以停下来了：
                break

            left -= 1
            right += 1 


```



















---
## Binary search 二分法

### 使用条件
1. 排序数组（30%-40% 是二分法）
2. 当面试官要求找一个比o(n)更小的时间复杂度算法的时候，99% 就是二分logn
3. 找到数组中的一个分割位置，使得左半部分满足某个条件，右半部分不满足 100% 就是二分
4. 找到一个最大、最小的值使得某个条件被满足 90% 
> time complexity - o(logn)； space complexity o(1)

### template 
```python
class Solution:
    def binary_search(self, nums, target):
        # corner case 处理 - 这里等价于num is None or len(num) == 0
        if not nums: return -1 
        # 初始化
        start, end = 0, len(nums) - 1
        # 用start + 1 < end 而不是 start < end 的目的是为了避免死循环
        # the first position of target 的情况下不会出现死循环，但是在last position of target 的情况下会出现死循环
        # example, nums = [1, 1]， target = 1 
        while start + 1 < end:
            mid = start + (end - start) // 2 
            # or mid = (start + end) // 2
            # > = < 的逻辑先分开写，然后在看看 = 的情况是否能合并到其他分支里
            if nums[mid] < target: 
                start = mid 
            elif nums[mid] == target:
                end = mid 
            else: 
                end = mid 
            # 因为上面的循环退出条件是 start + 1 < end 
            # 因此这里循环结束的时候， start 和 end 的关系是相邻关系 (1和2，3和4 这种)
            # 因此需要再单独判断 start 和 end 这两个数谁是我们想要的答案
            # 如果是找 first position of target 就先看start， 否则就先看end 
            if nums[start] == target:
                return start 
            if nums[end] == target: 
                return end 
        return -1 

```
### 1891 cut 木头的题，需要判定函数
```python
class Solution:
    def maxLength(self, ribbons: List[int], k: int) -> int:
        
        # 核心的难点是，能不能cut，我能想到左右边界1， max，但要定义一个cut函数
        # 这个函数就是说给定一个target，能不能cut用现在的ribbons
        
        def can_cut(target):
            count = 0 
            for num in ribbons:
                count += num // target    
            return count >= k 
        
        start, end = 1, max(ribbons)
        while start + 1 < end:
            mid = (start + end) // 2
            if can_cut(mid):
                start = mid 
            else:
                end = mid 
        
        if can_cut(end): return end
        if can_cut(start): return start
        
        return 0
```

### Problems
#### 显式二分
- #35. Search Insert Position https://leetcode.com/problems/search-insert-position/
    > 模板题

**多次二分** 
- #34. Find First and Last Position of Element in Sorted Array https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ 
    > 找排序数组的左右边界, 直接用模板，二次二分法
- #33. Search in Rotated Sorted Array https://leetcode.com/problems/search-in-rotated-sorted-array/
    > 也是从分割点，应用二次二分法

**山峰+多次二分** 
- #852. Peak Index in a Mountain Arrayhttps://leetcode.com/problems/peak-index-in-a-mountain-array/
    > 山峰最easy题
- #1095. Find in Mountain Array https://leetcode.com/problems/find-in-mountain-array/ 
    > 是一个hard， 首先二分要在sorted 上做，否则不work，上来先排序，然后找到peak value 用一次二分，然后分别堆两部分做2次二分
- #162. Find Peak Element https://leetcode.com/problems/find-peak-element/
    > 山峰类型题，根据要求，判断相邻大小然后对start 和 end check
- #1901. Find a Peak Element II https://leetcode.com/problems/find-a-peak-element-ii/ 
    > 山峰改为2D矩阵，比较难相比之前

**math + API 熟悉二分思想**
- #367. Valid Perfect Square https://leetcode.com/problems/valid-perfect-square/
    > math 题，练习二分思想
- #278. First Bad Version https://leetcode.com/problems/first-bad-version/ 
    > call API 的题，这里面target不是number，而是true or false
- #374. Guess Number Higher or Lower https://leetcode.com/problems/guess-number-higher-or-lower/
    > API 题，类似278，经典二分思想 
- #633. Sum of Square Numbers https://leetcode.com/problems/sum-of-square-numbers/
    > math 题，开始以为二分，但其实双指针更容易

**矩阵+二分**
- #74. Search a 2D Matrix https://leetcode.com/problems/search-a-2d-matrix/ 
    > 矩阵题，类似graph，一直处理的不好，这个题要重新做， 用模板 0307 update
- #240. Search a 2D Matrix II  https://leetcode.com/problems/search-a-2d-matrix-ii/
    > 矩阵题，可以暴力干，不是特别典型的二分，需要重新做，用模板，0307 update


#### 隐式二分
**不太理解的几个二分**
- #540. Single Element in a Sorted Array https://leetcode.com/problems/single-element-in-a-sorted-array/ 
    > 仍然不是很清楚，如何确定二分的条件，这个题需要理解成，奇偶数判断，然后移动mid， 需要再做
- #644. Maximum Average Subarray II https://leetcode.com/problems/maximum-average-subarray-ii/ 
    > 是一个hard，用到了前缀和，没做出来，需要再做
- #528. Random Pick with Weight https://leetcode.com/problems/random-pick-with-weight/
    > 不理解题含义

**写判定函数，注意边界**
- #1300. Sum of Mutated Array Closest to Target https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/ 
    > 一类题，需要写一个判定函数，然后注意边界，start, end = 0, max(arr) 否则出错
- #1060. Missing Element in Sorted Array https://leetcode.com/problems/missing-element-in-sorted-array/
    > 比1300 复杂，需要写missing function，不在边界内，如何选，处理边界问题， good题
- #1891. Cutting Ribbons https://leetcode.com/problems/cutting-ribbons/ 
    > 核心的难点是，能不能cut，我能想到左右边界1， max，但要定义一个cut函数:给定一个target，能不能cut用现在的ribbons
- #1011. Capacity To Ship Packages Within D Days https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/ 
    > 考判定函数的题，非常经典， 很多类似的题
- #875 Koko Eating Bananas  https://leetcode.com/problems/koko-eating-bananas/
    > 判定函数，和1011类似，一个模板可解决，注意边界是start, end = 1, max(piles)
- #1231. Divide Chocolate https://leetcode.com/problems/divide-chocolate/
    > 1011，875 同类型题，注意有一个边界case，需要单独处理
- #410. Split Array Largest Sum https://leetcode.com/problems/split-array-largest-sum/
    > 判定函数，start, end = max(nums), sum(nums) 注意细节，是个hard但不难

**二分混合其他**
- #2089. Find Target Indices After Sorting Array https://leetcode.com/problems/find-target-indices-after-sorting-array/
    > 多种解法，有一个统计解法，二分其实不是最优的
- #1062. Longest Repeating Substring https://leetcode.com/problems/longest-repeating-substring/
    > 哈希表+判断函数，这个是string，注意边界，start, end = 0, n

---
&emsp;
&emsp;
&emsp;

## Sorting 排序
python自带的sorted 排序算法是timsort
> best time - o(n), average and worst case is o(nlogn);  space o(n)

```python 
s = [1,5,3,6,2]
sorted(s) # [1, 2, 3, 5, 6]
sorted(s,reverse=True) #[6, 5, 3, 2, 1]
boxTypes = [[5,10],[2,5],[4,7],[3,9]]
sorted(boxTypes, key=lambda x:x[0]) # [[2, 5], [3, 9], [4, 7], [5, 10]]
sorted(boxTypes, key=lambda x:x[1]) # [[2, 5], [4, 7], [3, 9], [5, 10]]
sorted(boxTypes, key=lambda x:x[0], reverse=True) # [[5, 10], [4, 7], [3, 9], [2, 5]]
```

### Quick sort - time o(nlogn), space o(1)
> 先整体有序，再局部有序，利用分治的思想，递归的程序设计方式

```python
def sortIntegers(self, A):
    if A is None or len(A) == 0:
        return 
    self.quick_sort_helper(A, 0, len(A), 1)

def quick_sort_helper(self, A, start, end):
    # 递归的出口
    if start == end:
        return

    # 递归的拆解
    left, right = start, end 
    mid = A[start + (end - start) // 2]

    while left <= right:
        while left <= right and A[left] < mid:
            left += 1
        while left <= right and A[right] > mid:
            right -= 1
        if left == right:
            # 左右交换
            A[left], A[right] = A[right], A[left]
            left += 1
            right -= 1
    #递归
    self.quick_sort_helper(A, start, right)
    self.quick_sort_helper(A, left, end)
```

### Merge sort - time o(nlogn), space o(n)
> 先局部有序，再整体有序

```python
class Solution:
    def sorintegers(self, A):
        if not A:
            return A 

        temp = [0] * len(A) # 新开的space 所以o(n)
        self.merge_sort(A, 0, len(A) - 1, temp)

    def merge_sort(self, A, start, end, temp):
        if start >= end:
            return 

            # 处理左半区间
            self.merge_sort(A, start, (start + end) // 2, temp)
            # 处理右半区间
            self.merge_sort(A, (start + end) // 2 + 1, end, temp)
            # 合并排序数组
            self.merge(A, start, end, temp)

    def merge(self, A, start, end, temp):
        middle = (start + end) // 2
        left_index = start
        right_index = middle + 1
        index = start 

        while left_index <= middle and right_index <= end:
            if A[left_index] < A[right_index]:
                temp[index] = A[left_index]
                index += 1
                left_index += 1
            else:
                temp[index] = A[right_index]
                index += 1
                right_index += 1

        while left_index <= middle:
            temp[index] = A[left_index]
            index += 1
            left_index += 1

        while right_index <= end:
            temp[index] = A[right_index]
            index += 1
            right_index += 1

        for i in range(start, end + 1):
            A[i] = temp[i]

```


### Problems
- #148. Sort List https://leetcode.com/problems/sort-list/ 
    > 超级麻烦，要有merge sort，感觉这种排序题在linked list 难度很大，而且容易出
- #179. Largest Number https://leetcode.com/problems/largest-number/
    > 不理解，官方答案超玄乎，但还是高频很多地方考过！
- #75. Sort Colors https://leetcode.com/problems/sort-colors/ 
- #493. Reverse Pairs https://leetcode.com/problems/reverse-pairs/ 
- #23. Merge k Sorted Lists  https://leetcode.com/problems/merge-k-sorted-lists/ 




