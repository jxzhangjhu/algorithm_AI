## python 基础和常用技巧

- log.split(' ', 1) # 分割字符串
- log.isdight() 判断是否为数字，也要记住和ord结合使用！
- alpha.sort(key = lambda x: (x[1],x[0])) # 则会根据参数的第一个字段，第二个字段按照正序排列
- alpha.append((s[0],' '.join(j for j in s[1:]))) # join 就是加上
- join 用法和定义 Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。 
    > The join() method takes all items in an iterable and joins them into one string. A string must be specified as the separator.
- from collections import defaultdict 
    1. 使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict：
    2. 注意默认值是调用函数返回的，而函数在创建defaultdict对象时传入。 除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的。

- from collections import OrderedDict 
    1. 使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。如果要保持Key的顺序，可以用OrderedDict：
    2. 注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序：
    3. OrderedDict可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key：

- from collections import Counter 
    ``` python
    from collections import Counter
    target = 'abcdeddbac'
    s = Counter(target)
    Out - Counter({'a': 2, 'b': 2, 'c': 2, 'd': 3, 'e': 1}) #一个dict
    ```
- leetcode里面超过10000的规模，就不能用n^2的算法，只能nlogn以下的 [花花酱的视频不错]
- while else的使用！
- random 函数, choice从一个list上random出来一个value！
```python
from random import choice
s = [1,2,3,4,0,7,3,2]
choice(s)
```

- python 字符串和数字转换 ord() and chr() 用法，这个在array，string题中常用！
```python
# 转换一个字串符到数字 - 这个要熟记于心！basic calculator那个题就用到了！
s = '234'
# way 1 - int(s) 变成整数
# way 2
num = 0 
for char in s:
    num = num * 10 + ord(char) - ord('0')
print(num) # 234 
```

- python “/” and “//” 的区别
    > python中/和//的区别. “ / ” 为浮点数除法，返回浮点结果. “ // ” 表示整数除法






    

## prefix sum 前缀和和差分


### 前缀和
```python
nums = [1,2,3,4,5,6]
# s = (list(accumulate(nums)))

presum = 0 
arr = [0]*len(nums)
for i, num in enumerate(nums): 
    presum += num
    arr[i] = presum
# arr is [1, 3, 6, 10, 15, 21] 
```

### 差分
```python
diff = [0]*len(nums)
diff[0] = nums[0]
for i in range(1, len(nums)):
    diff[i] = nums[i] - nums[i-1]

presum = 0 
for num in diff:
    presum += num
    print(presum)
```



---
## stack, queue, heap 要求复习一下






--- 
## Tree 

### tree 概述
1. 一个中心: 遍历traverse
2. 两个基本点: BFS/DFS
3. 三种题型: 搜索类，构建类，修改类
4. 四个重要概念: 路径path， 距离distance，二叉搜索树BST(中序遍历排序)，完全二叉树
5. 七个技巧: dfs(root); 单双递归；前后遍历；虚拟节点；边界；参数扩展法；返回元组列表 


#### 二叉树的模板，前中后序的递归，迭代模板！

- 前序遍历 preorder - 中左右
```python 
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        
        result = []
        def traversal(node):
            if not node:
                return 
            result.append(node.val) # middle 
            traversal(node.left) # left
            traversal(node.right) # right
            return result
        
        traversal(root)
        return result 
```

- 中序遍历 inorder - 左中右
```python 
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        
        result = []
        def traversal(node):
            if not node:
                return 
            traversal(node.left) # left
            result.append(node.val) # middle 
            traversal(node.right) # right
            return result
        
        traversal(root)
        return result 
```

- 后序遍历 postorder - 左右中
```python 
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        
        result = []
        def traversal(node):
            if not node:
                return 
            traversal(node.left) # left
            traversal(node.right) # right
            result.append(node.val) # middle 
            return result
        
        traversal(root)
        return result 
```


#### 二叉树的迭代统一模板

- 前序遍历 preorder - 中左右
```python 
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st= []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                if node.right: #右
                    st.append(node.right)
                if node.left: #左
                    st.append(node.left)
                st.append(node) #中
                st.append(None)
            else:
                node = st.pop()
                result.append(node.val)
        return result
```

- 中序遍历 inorder - 左中右
```python 
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                if node.right: #添加右节点（空节点不入栈）
                    st.append(node.right)
                
                st.append(node) #添加中节点
                st.append(None) #中节点访问过，但是还没有处理，加入空节点做为标记。
                
                if node.left: #添加左节点（空节点不入栈）
                    st.append(node.left)
            else: #只有遇到空节点的时候，才将下一个节点放进结果集
                node = st.pop() #重新取出栈中元素
                result.append(node.val) #加入到结果集
        return result
```

- 后序遍历 postorder - 左右中
```python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                st.append(node) #中
                st.append(None)
                
                if node.right: #右
                    st.append(node.right)
                if node.left: #左
                    st.append(node.left)
            else:
                node = st.pop()
                result.append(node.val)
        return result
```


#### BFS 模板 - 和层级遍历还是有很大区别的
1. 带层 and 不带层
2. BFS 适合求最短距离/路径和某一距离的目标，找到目标节点，直接返回，DFS要穷举所有可能才能找到最近的

- 带层模板
```python
class Solution:
    def bfs(k): # what's k?
        queue = collections.deque([root])
        steps = 0 # 记录层数
        ans = [] # 需要返回的节点
        while queue: # 队列不空，生命不止
            size = len(queue) #当前层的长度，所有节点
            for i in range(size):
                node = queue.popleft() # 返回左边第一个节点
                if step == k:  # 到达指定层，添加节点
                    ans.append(node)
                if node.right:
                    queue.append(node.right)
                if node.left:
                    queue.append(node.left)
            # 遍历完当前层所有节点后，step + 1
            steps += 1
        return ans 
```
- 不带层模板
```python 
class Solution:
    def bfs(k):
        queue = collections.deque([root])
        ans = []
        while queue:
            node = queue.popleft()
            # 由于没有记录steps，肯定不需要根据层的信息去判断，否则急用带层模板
            if (node 是我们想要的): return node
            if node.right:
                queue.append(node.right)
            if node.left:
                queue.append(node.left)  
        return - 1          
```

#### DFS - 盲目搜索，加visit记录访问
```python
# 前序和后序遍历，取决于主要逻辑的位置
def dfs(root):
    # 跳出递归
    if not node: return
    # 主要逻辑 - 前序, e.g., result.append(node.val) # middle 
    dfs(root.left)
    dfs(root.right)
    # 主要逻辑 - 后续 e.g., result.append(node.val) # middle 

    # 也可能前后都有一些，但取决于主要逻辑的位置来判断是前序还是后序
```

### 主要核心题型： 搜索，构建，修改，BST/完全二叉树，路径/距离，BFS层级遍历

1. 构建题 - 构建普通二叉树和构建BST
2. 搜索
3. 修改
4. BST
5. 路径距离

6. BFS模板题
- #102. Binary Tree Level Order Traversal  https://leetcode.com/problems/binary-tree-level-order-traversal/ 
    > 模板题 BFS
- #107.Binary Tree Level Order Traversal II https://leetcode.com/problems/binary-tree-level-order-traversal-ii/
    > 从bottom 到top，直接对102 reverse 
- #429. N-ary Tree Level Order Traversal https://leetcode.com/problems/n-ary-tree-level-order-traversal/
    > 从binary 扩展到n-ary，完全一样的和102
- #199. Binary Tree Right Side View https://leetcode.com/problems/binary-tree-right-side-view/ 
    > 分层模板，if i == size - 1，就是最右侧，限定层内操作
- #637. Average of Levels in Binary Tree https://leetcode.com/problems/average-of-levels-in-binary-tree/
    > 分层模板，层内average
- #515. Find Largest Value in Each Tree Row https://leetcode.com/problems/find-largest-value-in-each-tree-row/
    > 分层模板，找层内最大值
- #116. Populating Next Right Pointers in Each Node  https://leetcode.com/problems/populating-next-right-pointers-in-each-node/
    > 分层模板，层内+指针，if i == size-1:break // node.next = que[0]
- #117. Populating Next Right Pointers in Each Node II https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/
    > 和116 完全一样
- #104. Maximum Depth of Binary Tree https://leetcode.com/problems/maximum-depth-of-binary-tree/
    > 分层模板，就是层数，也可以用dfs
- #111. Minimum Depth of Binary Tree https://leetcode.com/problems/minimum-depth-of-binary-tree/
    > 分层模板，但是要记录层数, 返回元组和列表 
```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        # 别忘了特判，要不过不去
        if not root:return 0 
        queue = collections.deque([(root,1)]) # 0 is depth
        while queue:
            cur_node, depth = queue.popleft()
            if not cur_node.left and not cur_node.right:
                return depth 
            if cur_node.left:
                queue.append((cur_node.left, depth + 1))
            if cur_node.right:
                queue.append((cur_node.right, depth + 1))
        return 0
```




<!-- 二叉树的序列化和反序列化 · Serialize and Deserialize Binary Tree -->




































---
## Array and string 

### 括号题
    整理，各种各样，主要和stack相关，最后''.join(s), s is list, 这个是list to string 
```python
# 20. Valid Parentheses - time o(n), space o(n)
class Solution:
    def isValid(self, s: str) -> bool:
    # 思路就是 left 就是open parentheses 
    hashm = {')':'(', ']':'[', '}':'{'} # 先定义hashtable to map parenthese pairs 
    stack = [] # 最后如何都可以match，pop完，就是完成任务
    for char in s:
        if char in hashm: # overidea 就是左括号就是进stack，然后右括号要判断是否弹stack，后进先出，stack
            if stack and stack[-1] == hashm[char]: # 要注意判断stack是否存在，同时栈顶元素
                stack.pop()
            else:
                return False        
        else:
            stack.append(char)
        
    if not stack:
        return True
```

- #1249. Minimum Remove to Make Valid Parentheses 
    >string to list and then use stack 




---
## Double pointer 双指针
### 使用条件
1. 滑动窗口 - 90% 的概率
2. 时间复杂度要求 O(n) - 80%的概率
3. 要求原地操作，只可以交换使用，不能使用额外空间，所以空间复杂度O(1) - 80% 
4. 有子数组subarray， 子字符串substring的关键词 - 50%
5. 有回文问题 palindrome 关键词 - 50% 

### time complexity
>> 时间复杂度与最内层循环主体的loop执行次数有关， 与有多少重循环无关，O(n) 
### space complexity
>> 只需要分配2个指针的额外内存，所以space 是O(1)

### 几种类型的双指针及相关题目
1. 同向：特点是指针不回头，全0 子串数量 - slow，fast， 基本等价于sliding window 
2. 相向：two sum， three sum， left， right
3. 背向：最长回文子串

### 相向双指针 - two sum 为主 start and end； 还有partition类型
Template
```python
class Solution:
    def patition(self, A, start, end):
        if start >= end:
            return 

        left, right = start, end
        # key point 1: pivot is the value, not the index 
        pivot = A[(start + end) // 2]
        # key point 2: every time you compare left & right, it should be left <= right not left < right 
        while left <= right:
            while left <= right and A[left] < pivot:
                left += 1
            while left <= right and A[right] > pivot: 
                right -= 1
            if left <= right:
                A[left], A[right] = A[right], A[left]
                left += 1
                right -= 1

# two sum 先排序，才能用相向双指针 
            nums = [(number, index) for index, number in enumerate(nums)]
            nums.sort()
            
            left, right = 0, len(nums) - 1
            while left < right:
                if nums[left][0] + nums[right][0] < target: # 小于target，left 右移
                    left += 1
                elif nums[left][0] + nums[right][0] > target: # 大于target，right 左移
                    right -= 1
                else: # 这个必须要有，就是说 == target，直接返回
                    return sorted([nums[left][1], nums[right][1]]) # 是否拍需要看要求，这个需要从小到大，就排一下
            return 
# three sum
        if len(nums) < 3:
            return 
        
        n = len(nums)
        nums.sort()
        ans = []
        for i in range(n):
            left = i + 1
            right = n - 1
            if nums[i] > 0: #最小值大于0
                break
            if i >= 1 and nums[i] == nums[i-1]: # 差一点，i >=1 才行，这种去重的题还是挺不好弄的！
                continue # 如果相邻的重复，那么就move一下，去掉重复的，直接跳过这个loop
            # left, right = 0, n - 1 # 不是这样的，要和i相关
            while left < right:
                target = nums[i] + nums[left] + nums[right]
                if target < 0:
                    left += 1
                elif target > 0:
                    right -= 1
                else:
                    ans.append([nums[i], nums[left], nums[right]])
                    while left != right and nums[left] == nums[left + 1]: # 去重 left
                        left += 1
                    while left != right and nums[right] == nums[right - 1]: # 去重 right
                        right -= 1
                    left += 1
                    right -= 1
        return ans
# 4sum hashmap, time o(n^2), space o(n^2)
        hashmap = {}
        for i in nums1:
            for j in nums2:
                if i + j in hashmap:
                    hashmap[i + j] += 1
                else:
                    hashmap[i + j] = 1
            
        res = 0
        for m in nums3:
            for n in nums4:
                if 0 - m - n in hashmap:
                    res += hashmap[0 - m - n]
                    
        return res
```

### Problems
- #1. Two Sum 
    > 暴力double for loop -> hashtable -> 排序双指针(如何排序 + index操作需要注意); 这里要求返回下面，如果返回值比较容易
- #167. Two Sum II - Input Array Is Sorted https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ 
    > 排序之后返回index，比two sum 简单， 我觉得只有排序之后，才能相向双指针，否则没有意义
- #15. 3Sum https://leetcode.com/problems/3sum/
    > 最外层for loop 作为一个指针，内嵌while loop，考虑left，right指针, 这个难点在于去重，去重很多种办法， 包括set，还有左右移动，因为已经排序，所以用相邻位置的比较来去重
- #16. 3Sum Closest https://leetcode.com/problems/3sum-closest/ 
    > 比15简单，几个edge cases都考虑到了
- #259. 3Sum Smaller https://leetcode.com/problems/3sum-smaller/ 
    > res += right - left # 这步是关键，之前没有想清楚， 为什么是right-left，其实就是中间的都可以
- #18. 4Sum https://leetcode.com/problems/4sum/ 
    > 完全和3sum一样！ 就是复杂的一点, time o(n^3), space o(n) 
- #454. 4Sum II https://leetcode.com/problems/4sum-ii/ 
    > # hashmap, time o(n^2), space o(n^2) 



### 同向双指针 - 快慢指针 slow，fast； slideing window - 区间题
Template  - 九章，这个不太通用，很多用不了！
```python
class Solution:
    def patition(self, A, start, end):
        j = 0
        for i in range(n):
            # 不满足则循环到满足搭配为止

            while j < n and i and j 之间不满足条件:
                j += 1

            if i到j之间满足条件:
                处理i到j这段区间 

```











### 背向双指针 - 回文子串题
Template 
```python
class Solution:
    def patition(self, A, start, end):

        left = position 
        right = position + 1
        while left >=0 and right < len(s):
            if left and right 可以停下来了：
                break

            left -= 1
            right += 1 


```



















---
## Binary search 二分法

### 使用条件
1. 排序数组（30%-40% 是二分法）
2. 当面试官要求找一个比o(n)更小的时间复杂度算法的时候，99% 就是二分logn
3. 找到数组中的一个分割位置，使得左半部分满足某个条件，右半部分不满足 100% 就是二分
4. 找到一个最大、最小的值使得某个条件被满足 90% 
> time complexity - o(logn)； space complexity o(1)

### template 
```python
class Solution:
    def binary_search(self, nums, target):
        # corner case 处理 - 这里等价于num is None or len(num) == 0
        if not nums: return -1 
        # 初始化
        start, end = 0, len(nums) - 1
        # 用start + 1 < end 而不是 start < end 的目的是为了避免死循环
        # the first position of target 的情况下不会出现死循环，但是在last position of target 的情况下会出现死循环
        # example, nums = [1, 1]， target = 1 
        while start + 1 < end:
            mid = start + (end - start) // 2 
            # or mid = (start + end) // 2
            # > = < 的逻辑先分开写，然后在看看 = 的情况是否能合并到其他分支里
            if nums[mid] < target: 
                start = mid 
            elif nums[mid] == target:
                end = mid 
            else: 
                end = mid 
            # 因为上面的循环退出条件是 start + 1 < end 
            # 因此这里循环结束的时候， start 和 end 的关系是相邻关系 (1和2，3和4 这种)
            # 因此需要再单独判断 start 和 end 这两个数谁是我们想要的答案
            # 如果是找 first position of target 就先看start， 否则就先看end 
            if nums[start] == target:
                return start 
            if nums[end] == target: 
                return end 
        return -1 

```
### 1891 cut 木头的题，需要判定函数
```python
class Solution:
    def maxLength(self, ribbons: List[int], k: int) -> int:
        
        # 核心的难点是，能不能cut，我能想到左右边界1， max，但要定义一个cut函数
        # 这个函数就是说给定一个target，能不能cut用现在的ribbons
        
        def can_cut(target):
            count = 0 
            for num in ribbons:
                count += num // target    
            return count >= k 
        
        start, end = 1, max(ribbons)
        while start + 1 < end:
            mid = (start + end) // 2
            if can_cut(mid):
                start = mid 
            else:
                end = mid 
        
        if can_cut(end): return end
        if can_cut(start): return start
        
        return 0
```

### Problems
#### 显式二分
- #35. Search Insert Position https://leetcode.com/problems/search-insert-position/
    > 模板题

**多次二分** 
- #34. Find First and Last Position of Element in Sorted Array https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ 
    > 找排序数组的左右边界, 直接用模板，二次二分法
- #33. Search in Rotated Sorted Array https://leetcode.com/problems/search-in-rotated-sorted-array/
    > 也是从分割点，应用二次二分法

**山峰+多次二分** 
- #852. Peak Index in a Mountain Arrayhttps://leetcode.com/problems/peak-index-in-a-mountain-array/
    > 山峰最easy题
- #1095. Find in Mountain Array https://leetcode.com/problems/find-in-mountain-array/ 
    > 是一个hard， 首先二分要在sorted 上做，否则不work，上来先排序，然后找到peak value 用一次二分，然后分别堆两部分做2次二分
- #162. Find Peak Element https://leetcode.com/problems/find-peak-element/
    > 山峰类型题，根据要求，判断相邻大小然后对start 和 end check
- #1901. Find a Peak Element II https://leetcode.com/problems/find-a-peak-element-ii/ 
    > 山峰改为2D矩阵，比较难相比之前

**math + API 熟悉二分思想**
- #367. Valid Perfect Square https://leetcode.com/problems/valid-perfect-square/
    > math 题，练习二分思想
- #278. First Bad Version https://leetcode.com/problems/first-bad-version/ 
    > call API 的题，这里面target不是number，而是true or false
- #374. Guess Number Higher or Lower https://leetcode.com/problems/guess-number-higher-or-lower/
    > API 题，类似278，经典二分思想 
- #633. Sum of Square Numbers https://leetcode.com/problems/sum-of-square-numbers/
    > math 题，开始以为二分，但其实双指针更容易

**矩阵+二分**
- #74. Search a 2D Matrix https://leetcode.com/problems/search-a-2d-matrix/ 
    > 矩阵题，类似graph，一直处理的不好，这个题要重新做， 用模板 0307 update
- #240. Search a 2D Matrix II  https://leetcode.com/problems/search-a-2d-matrix-ii/
    > 矩阵题，可以暴力干，不是特别典型的二分，需要重新做，用模板，0307 update


#### 隐式二分
**不太理解的几个二分**
- #540. Single Element in a Sorted Array https://leetcode.com/problems/single-element-in-a-sorted-array/ 
    > 仍然不是很清楚，如何确定二分的条件，这个题需要理解成，奇偶数判断，然后移动mid， 需要再做
- #644. Maximum Average Subarray II https://leetcode.com/problems/maximum-average-subarray-ii/ 
    > 是一个hard，用到了前缀和，没做出来，需要再做
- #528. Random Pick with Weight https://leetcode.com/problems/random-pick-with-weight/
    > 不理解题含义

**写判定函数，注意边界**
- #1300. Sum of Mutated Array Closest to Target https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/ 
    > 一类题，需要写一个判定函数，然后注意边界，start, end = 0, max(arr) 否则出错
- #1060. Missing Element in Sorted Array https://leetcode.com/problems/missing-element-in-sorted-array/
    > 比1300 复杂，需要写missing function，不在边界内，如何选，处理边界问题， good题
- #1891. Cutting Ribbons https://leetcode.com/problems/cutting-ribbons/ 
    > 核心的难点是，能不能cut，我能想到左右边界1， max，但要定义一个cut函数:给定一个target，能不能cut用现在的ribbons
- #1011. Capacity To Ship Packages Within D Days https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/ 
    > 考判定函数的题，非常经典， 很多类似的题
- #875 Koko Eating Bananas  https://leetcode.com/problems/koko-eating-bananas/
    > 判定函数，和1011类似，一个模板可解决，注意边界是start, end = 1, max(piles)
- #1231. Divide Chocolate https://leetcode.com/problems/divide-chocolate/
    > 1011，875 同类型题，注意有一个边界case，需要单独处理
- #410. Split Array Largest Sum https://leetcode.com/problems/split-array-largest-sum/
    > 判定函数，start, end = max(nums), sum(nums) 注意细节，是个hard但不难

**二分混合其他**
- #2089. Find Target Indices After Sorting Array https://leetcode.com/problems/find-target-indices-after-sorting-array/
    > 多种解法，有一个统计解法，二分其实不是最优的
- #1062. Longest Repeating Substring https://leetcode.com/problems/longest-repeating-substring/
    > 哈希表+判断函数，这个是string，注意边界，start, end = 0, n

---
&emsp;
&emsp;
&emsp;

## Sorting 排序
python自带的sorted 排序算法是timsort
> best time - o(n), average and worst case is o(nlogn);  space o(n)

```python 
s = [1,5,3,6,2]
sorted(s) # [1, 2, 3, 5, 6]
sorted(s,reverse=True) #[6, 5, 3, 2, 1]
boxTypes = [[5,10],[2,5],[4,7],[3,9]]
sorted(boxTypes, key=lambda x:x[0]) # [[2, 5], [3, 9], [4, 7], [5, 10]]
sorted(boxTypes, key=lambda x:x[1]) # [[2, 5], [4, 7], [3, 9], [5, 10]]
sorted(boxTypes, key=lambda x:x[0], reverse=True) # [[5, 10], [4, 7], [3, 9], [2, 5]]
```

### Quick sort - time o(nlogn), space o(1)
> 先整体有序，再局部有序，利用分治的思想，递归的程序设计方式

```python
def sortIntegers(self, A):
    if A is None or len(A) == 0:
        return 
    self.quick_sort_helper(A, 0, len(A), 1)

def quick_sort_helper(self, A, start, end):
    # 递归的出口
    if start == end:
        return

    # 递归的拆解
    left, right = start, end 
    mid = A[start + (end - start) // 2]

    while left <= right:
        while left <= right and A[left] < mid:
            left += 1
        while left <= right and A[right] > mid:
            right -= 1
        if left == right:
            # 左右交换
            A[left], A[right] = A[right], A[left]
            left += 1
            right -= 1
    #递归
    self.quick_sort_helper(A, start, right)
    self.quick_sort_helper(A, left, end)
```

### Merge sort - time o(nlogn), space o(n)
> 先局部有序，再整体有序

```python
class Solution:
    def sorintegers(self, A):
        if not A:
            return A 

        temp = [0] * len(A) # 新开的space 所以o(n)
        self.merge_sort(A, 0, len(A) - 1, temp)

    def merge_sort(self, A, start, end, temp):
        if start >= end:
            return 

            # 处理左半区间
            self.merge_sort(A, start, (start + end) // 2, temp)
            # 处理右半区间
            self.merge_sort(A, (start + end) // 2 + 1, end, temp)
            # 合并排序数组
            self.merge(A, start, end, temp)

    def merge(self, A, start, end, temp):
        middle = (start + end) // 2
        left_index = start
        right_index = middle + 1
        index = start 

        while left_index <= middle and right_index <= end:
            if A[left_index] < A[right_index]:
                temp[index] = A[left_index]
                index += 1
                left_index += 1
            else:
                temp[index] = A[right_index]
                index += 1
                right_index += 1

        while left_index <= middle:
            temp[index] = A[left_index]
            index += 1
            left_index += 1

        while right_index <= end:
            temp[index] = A[right_index]
            index += 1
            right_index += 1

        for i in range(start, end + 1):
            A[i] = temp[i]

```


### Problems
- #148. Sort List https://leetcode.com/problems/sort-list/ 
    > 超级麻烦，要有merge sort，感觉这种排序题在linked list 难度很大，而且容易出
- #179. Largest Number https://leetcode.com/problems/largest-number/
    > 不理解，官方答案超玄乎，但还是高频很多地方考过！
- #75. Sort Colors https://leetcode.com/problems/sort-colors/ 
- #493. Reverse Pairs https://leetcode.com/problems/reverse-pairs/ 
- #23. Merge k Sorted Lists  https://leetcode.com/problems/merge-k-sorted-lists/ 




